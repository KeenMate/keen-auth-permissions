/*
 GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=0&v=1&c=c&f=ANSI%20Shadow&t=STAGE%20FUNCS

 SUB GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=1&v=1&c=c&f=Banner3&t=permissions

 */

create extension if not exists "uuid-ossp" schema ext;
create extension if not exists ltree schema ext;
create extension if not exists unaccent schema ext;

/***
 *    ██╗--██╗███████╗██╗-----██████╗-███████╗██████╗-███████╗
 *    ██║--██║██╔════╝██║-----██╔══██╗██╔════╝██╔══██╗██╔════╝
 *    ███████║█████╗--██║-----██████╔╝█████╗--██████╔╝███████╗
 *    ██╔══██║██╔══╝--██║-----██╔═══╝-██╔══╝--██╔══██╗╚════██║
 *    ██║--██║███████╗███████╗██║-----███████╗██║--██║███████║
 *    ╚═╝--╚═╝╚══════╝╚══════╝╚═╝-----╚══════╝╚═╝--╚═╝╚══════╝
 *    --------------------------------------------------------
 */

create function helpers.random_string(len integer DEFAULT 36) returns text
    stable cost 1
    language sql as
$$
select upper(substring(md5(random() :: text), 0, len + 1));

$$;

create
    or replace function helpers.get_code(_title text, _separator text default '-') returns text
    stable returns null on null input
    language sql as
$$

    -- removes accents (diacritic signs) from a given string --
with _unaccented as (select ext.unaccent(_title) as _title),
-- lowercases the string
     _lowercase as (select lower(_title) as _title
                    from _unaccented),
-- replaces anything that's not a letter, number, hyphen('-'), or underscore('_') with a hyphen('-')
     _hyphenated as (select regexp_replace(_title, '[^a-z0-9\\-_]+', _separator, 'gi') as _title
                     from _lowercase),
-- trims hyphens('-') if they exist on the head or tail of the string
     _trimmed as (select regexp_replace(regexp_replace(_title, '\' || _separator || '+$', ''), '^\' || _separator,
                                        '') as _title
                  from _hyphenated)
select _title
from _trimmed;

$$;

create function helpers.ltree_parent(path ext.ltree, levels integer DEFAULT 1) returns ext.ltree
    language plpgsql as
$$
begin
    return ext.subpath(path, 0, ext.nlevel(path) - levels);

end
$$;

create function auth.get_user_random_code()
    returns text
    language sql
    immutable
    cost 1
as
$$
select helpers.random_string(8);
$$;

/***
 *    ████████╗███████╗███╗---███╗██████╗-██╗------█████╗-████████╗███████╗███████╗
 *    ╚══██╔══╝██╔════╝████╗-████║██╔══██╗██║-----██╔══██╗╚══██╔══╝██╔════╝██╔════╝
 *    ---██║---█████╗--██╔████╔██║██████╔╝██║-----███████║---██║---█████╗--███████╗
 *    ---██║---██╔══╝--██║╚██╔╝██║██╔═══╝-██║-----██╔══██║---██║---██╔══╝--╚════██║
 *    ---██║---███████╗██║-╚═╝-██║██║-----███████╗██║--██║---██║---███████╗███████║
 *    ---╚═╝---╚══════╝╚═╝-----╚═╝╚═╝-----╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝╚══════╝
 *    -----------------------------------------------------------------------------
 */

create table public._template_created
(
    created    timestamp with time zone               default now()             not null,
    created_by text check (length(created_by) <= 250) default 'unknown' :: text not null
);

create table public._template_timestamps
(
    modified    timestamp with time zone                default now()             not null,
    modified_by text check (length(modified_by) <= 250) default 'unknown' :: text not null
) inherits (_template_created);

/***
 *    ████████╗██████╗-██╗-██████╗--██████╗-███████╗██████╗-███████╗
 *    ╚══██╔══╝██╔══██╗██║██╔════╝-██╔════╝-██╔════╝██╔══██╗██╔════╝
 *    ---██║---██████╔╝██║██║--███╗██║--███╗█████╗--██████╔╝███████╗
 *    ---██║---██╔══██╗██║██║---██║██║---██║██╔══╝--██╔══██╗╚════██║
 *    ---██║---██║--██║██║╚██████╔╝╚██████╔╝███████╗██║--██║███████║
 *    ---╚═╝---╚═╝--╚═╝╚═╝-╚═════╝--╚═════╝-╚══════╝╚═╝--╚═╝╚══════╝
 *    --------------------------------------------------------------
 */

CREATE
    OR REPLACE FUNCTION helpers.trg_generate_code_from_title()
    RETURNS trigger
    LANGUAGE plpgsql AS
$$
BEGIN
    NEW.code := helpers.get_code(NEW.title, '_');

    RETURN NEW;
END
$$;

/***
 *    ███████╗██╗   ██╗███████╗████████╗███████╗███╗   ███╗    ████████╗ █████╗ ██████╗ ██╗     ███████╗███████╗
 *    ██╔════╝╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔════╝████╗ ████║    ╚══██╔══╝██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
 *    ███████╗ ╚████╔╝ ███████╗   ██║   █████╗  ██╔████╔██║       ██║   ███████║██████╔╝██║     █████╗  ███████╗
 *    ╚════██║  ╚██╔╝  ╚════██║   ██║   ██╔══╝  ██║╚██╔╝██║       ██║   ██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
 *    ███████║   ██║   ███████║   ██║   ███████╗██║ ╚═╝ ██║       ██║   ██║  ██║██████╔╝███████╗███████╗███████║
 *    ╚══════╝   ╚═╝   ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝       ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝
 *
 */

create table const.sys_params
(
    sys_param_id int generated always as identity not null primary key,
    group_code   text                             not null,
    code         text                             not null,
    text_value   text,
    number_value bigint,
    bool_value   bool
) inherits (_template_timestamps);

create unique index uq_sys_params on const.sys_params (group_code, code);

create table auth.provider
(
    provider_id int generated always as identity not null primary key,
    code        text                             not null unique,
    name        text                             not null,
    is_active   bool                             not null default true
) inherits (_template_timestamps);

create table tenant
(
    tenant_id     int generated always as identity not null primary key,
    uuid          uuid                             not null default ext.uuid_generate_v4(), -- if you need this kind of identifier, it's ready for you
    name          text                             not null,
    code          text                             not null,
    is_removable  bool                             not null default true,
    is_assignable bool                             not null default true
) inherits (_template_timestamps);

create table user_info
(
    user_id                 bigint generated always as identity not null primary key,
    code                    text                                not null default auth.get_user_random_code(), -- if you need this kind of identifier, it's ready for you
    uuid                    uuid                                not null default ext.uuid_generate_v4(),      -- if you need this kind of identifier, it's ready for you
    can_login               bool                                not null default true,
    username                text                                not null check (length(username) <= 255 ),
    email                   text check (length(email) <= 255 ),
    display_name            text                                not null check (length(display_name) <= 255 ),
    is_system               bool                                not null default false,
    is_active               bool                                not null default true,
    is_locked               bool                                not null default false,
    last_used_provider_code text                                references auth.provider (code) on update set null
) inherits (_template_timestamps);

create unique index uq_user_info on user_info (email);

create table tenant_user
(
    tenant_user_id bigint generated always as identity not null primary key,
    tenant_id      int                                 not null references tenant (tenant_id) on delete cascade,
    user_id        int                                 not null references user_info (user_id) on delete cascade
) inherits (_template_created);

create table auth.user_permission_cache
(
    upc_id          bigint generated always as identity not null primary key,
    user_id         bigint                              not null references user_info (user_id),
    tenant_id       int                                 not null references tenant (tenant_id),
    groups          text[]                              not null default '{}',
    permissions     text[]                              not null default '{}',
    expiration_date timestamptz                         not null
) inherits (_template_timestamps);


-- can be replaced with your version of user data
create table user_data
(
    user_data_id bigint generated always as identity not null primary key,
    user_id      bigint                              not null references user_info (user_id) on delete cascade,
    first_name   text,
    middle_name  text,
    last_name    text

) inherits (_template_timestamps);

create table user_identity
(
    user_identity_id bigint generated always as identity not null primary key,
    provider_code    text                                not null references auth.provider (code) on update cascade on delete cascade,
    uid              text,
    user_id          bigint references user_info (user_id) on delete cascade,
    provider_groups  text[],
    provider_roles   text[],
    user_data        jsonb,
    password_hash    text,
    password_salt    text
) inherits (_template_timestamps);

create unique index uq_user_identity on user_identity (provider_code, uid);

create table auth.permission
(
    permission_id int generated always as identity not null primary key,
    is_assignable bool                             not null default true,
    title         text                             not null,
    code          text,
    full_code     ext.ltree,
    node_path     ext.ltree,
    has_children  bool                             not null default false,
    full_title    text
) inherits (_template_timestamps);

create index ix_permission_node_path on auth.permission using GIST (node_path);

create table auth.perm_set
(
    perm_set_id   int generated always as identity not null primary key,
    tenant_id     int references tenant (tenant_id) on delete cascade,
    title         text                             not null,
    code          text                             not null unique, -- set with trigger
    is_system     bool                             not null default false,
    is_assignable bool                             not null default true
) inherits (_template_timestamps);

create trigger c_perm_set_code
    before insert
    on auth.perm_set
    for each row
execute procedure helpers.trg_generate_code_from_title();

create table auth.perm_set_perm
(
    psp_id        int generated always as identity not null primary key,
    perm_set_id   int                              not null references perm_set (perm_set_id) on delete cascade,
    permission_id int                              not null references permission (permission_id) on delete cascade
) inherits (_template_created);

create table user_group
(
    user_group_id int generated always as identity not null primary key,
    tenant_id     int references tenant (tenant_id),
    title         text                             not null,
    code          text                             not null, -- set with trigger
    is_default    bool                             not null default false,
    is_system     bool                             not null default false,
    is_external   bool                             not null default false,
    is_assignable bool                             not null default true,
    is_active     bool                             not null default true
) inherits (_template_timestamps);

create trigger c_user_group_code
    before insert
    on user_group
    for each row
execute procedure helpers.trg_generate_code_from_title();

create table user_group_mapping
(
    ug_mapping_id      int generated always as identity not null primary key,
    group_id           int                              not null references user_group (user_group_id),
    provider_code      text                             not null references auth.provider (code) on update cascade on delete cascade,
    mapped_object_id   text,
    mapped_object_name text,
    mapped_role        text
) inherits (_template_created);

create unique index uq_user_group_mapping on user_group_mapping (group_id, provider_code,
                                                                 coalesce(mapped_object_id, ''),
                                                                 coalesce(mapped_role, ''));

create table user_group_member
(
    member_id         bigint generated always as identity not null primary key,
    group_id          int                                 not null references user_group (user_group_id) on delete cascade,
    user_id           int                                 not null references user_info (user_id) on delete cascade,
    mapping_id        int references user_group_mapping (ug_mapping_id) on delete cascade,
    manual_assignment bool                                not null default false
) inherits (_template_created);

create unique index uq_user_group_member ON user_group_member (group_id, user_id, coalesce(mapping_id, 0));

create table permission_assignment
(
    assignment_id int generated always as identity not null primary key,
    tenant_id     int references tenant (tenant_id) on delete cascade,
    group_id      int                              not null references user_group (user_group_id),
    user_id       bigint references user_info (user_id),
    perm_set_id   int references auth.perm_set (perm_set_id),
    permission_id int references auth.permission (permission_id),
    CONSTRAINT pa_either_object CHECK (group_id is not null or user_id is not null),
    CONSTRAINT pa_either_perm CHECK (perm_set_id is not null or permission_id is not null)
) inherits (_template_created);

create unique index uq_permission_assignment ON permission_assignment (group_id, coalesce(user_id, 0),
                                                                       coalesce(perm_set_id, 0),
                                                                       coalesce(permission_id, 0));

create table journal
(
    journal_id     bigint generated always as identity not null,
    tenant_id      int references tenant (tenant_id),
    data_group     text,
    data_object_id bigint,
    event_id       int,
    user_id        bigint                              references user_info (user_id) on delete set null,
    message        text                                not null,
    data_payload   jsonb
) inherits (_template_created);

create index ix_journal on journal (tenant_id, data_group, data_object_id);

/***
 *    ██╗   ██╗██╗███████╗██╗    ██╗███████╗
 *    ██║   ██║██║██╔════╝██║    ██║██╔════╝
 *    ██║   ██║██║█████╗  ██║ █╗ ██║███████╗
 *    ╚██╗ ██╔╝██║██╔══╝  ██║███╗██║╚════██║
 *     ╚████╔╝ ██║███████╗╚███╔███╔╝███████║
 *      ╚═══╝  ╚═╝╚══════╝ ╚══╝╚══╝ ╚══════╝
 *
 */

create view user_groups as
(
select ug.tenant_id
     , case when t.code is null then 'system' else t.code end                             as tenant_code
     , ui.user_id
     , ui.display_name                                                                    as user_display_name
     , ui.uuid                                                                            as user_uuid
     , ui.code                                                                            as user_code
     , ug.user_group_id
     , ug.is_external
     , ug.title                                                                           as group_title
     , ug.code                                                                            as group_code
     , case when ugm.mapping_id is not null then 'mapped_member' else 'direct_member' end as member_type
     , ugm.manual_assignment
     , u.mapped_object_name
     , u.mapped_role
from user_group_member ugm
         inner join user_info ui
                    on ui.user_id = ugm.user_id
         inner join user_group ug on ugm.group_id = ug.user_group_id
         inner join tenant t on ug.tenant_id = t.tenant_id
         left join user_group_mapping u on ugm.mapping_id = u.ug_mapping_id
    );

create view effective_permissions as
(
select distinct ps.perm_set_id,
                ps.code          as perm_set_code,
                ps.title         as perm_set_title,
                ps.is_assignable as perm_set_is_assignable,
                sp.permission_id,
                sp.title         as permission_title,
                sp.full_code     as permission_code,
                sp.is_assignable as permission_is_assignable
from auth.perm_set ps
         inner join auth.perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
         inner join auth.permission p on psp.permission_id = p.permission_id
         inner join auth.permission sp on sp.node_path <@ p.node_path);

/***
 *    -----██╗-██████╗-██╗---██╗██████╗-███╗---██╗-█████╗-██╗----------██████╗-██████╗-███████╗██████╗--█████╗-████████╗██╗-██████╗-███╗---██╗███████╗
 *    -----██║██╔═══██╗██║---██║██╔══██╗████╗--██║██╔══██╗██║---------██╔═══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗--██║██╔════╝
 *    -----██║██║---██║██║---██║██████╔╝██╔██╗-██║███████║██║---------██║---██║██████╔╝█████╗--██████╔╝███████║---██║---██║██║---██║██╔██╗-██║███████╗
 *    ██---██║██║---██║██║---██║██╔══██╗██║╚██╗██║██╔══██║██║---------██║---██║██╔═══╝-██╔══╝--██╔══██╗██╔══██║---██║---██║██║---██║██║╚██╗██║╚════██║
 *    ╚█████╔╝╚██████╔╝╚██████╔╝██║--██║██║-╚████║██║--██║███████╗----╚██████╔╝██║-----███████╗██║--██║██║--██║---██║---██║╚██████╔╝██║-╚████║███████║
 *    -╚════╝--╚═════╝--╚═════╝-╚═╝--╚═╝╚═╝--╚═══╝╚═╝--╚═╝╚══════╝-----╚═════╝-╚═╝-----╚══════╝╚═╝--╚═╝╚═╝--╚═╝---╚═╝---╚═╝-╚═════╝-╚═╝--╚═══╝╚══════╝
 *    ------------------------------------------------------------------------------------------------------------------------------------------------
 */

create or replace function add_journal_msg_jsonb(_created_by text, _tenant_id int, _user_id bigint, _msg text,
                                                 _data_group text default 'system',
                                                 _data_object_id bigint default null
    , _payload jsonb default null
    , _event_id int default null)
    returns setof journal
    language plpgsql
    rows 1
as
$$
begin
    return query
        insert into journal (created_by, tenant_id, data_group, data_object_id, event_id, user_id, message,
                             data_payload)
            values (_created_by, _tenant_id, _data_group, _data_object_id, _event_id, _user_id, _msg,
                    case when _payload is not null then _payload end)
            returning *;
end;
$$;

create or replace function add_journal_msg(_created_by text, _tenant_id int, _user_id bigint, _msg text,
                                           _data_group text default 'system',
                                           _data_object_id bigint default null
    , _payload text[] default null
    , _event_id int default null)
    returns setof journal
    language sql
as
$$

-- noinspection SqlConstantExpression

select *
from add_journal_msg_jsonb(_created_by, _tenant_id, _user_id, _msg, _data_group, _data_object_id,
                           case when _payload is null then null else jsonb_build_object(variadic _payload) end
    , _event_id)
$$;

create or replace function get_journal_msgs(_tenant_id int, _user_id int, _from timestamptz, _to timestamptz)
    returns table
            (
                __journal_id     bigint,
                __created        timestamptz,
                __created_by     text,
                __data_group     text,
                __data_object_id bigint,
                __user_id        bigint,
                __msg            text
            )
    language plpgsql
    stable
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.journal.read_journal');

    select journal_id
         , created
         , created_by
         , data_group
         , data_object_id
         , user_id
         , message
    from journal
    where tenant_id = _tenant_id
      and created between _from and _to;
end;
$$;

create or replace function get_journal_payload(_tenant_id int, _user_id int, _journal_id bigint)
    returns table
            (
                __journal_id bigint,
                __payload    text
            )
    language plpgsql
    stable
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.journal.get_payload');

    return query
        select journal_id
             , data_payload::text
        from journal
        where tenant_id = _tenant_id
          and journal_id = _journal_id;
end;
$$;


/***
 *    ███████╗██╗   ██╗███████╗    ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
 *    ██╔════╝╚██╗ ██╔╝██╔════╝    ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
 *    ███████╗ ╚████╔╝ ███████╗    █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
 *    ╚════██║  ╚██╔╝  ╚════██║    ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
 *    ███████║   ██║   ███████║    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
 *    ╚══════╝   ╚═╝   ╚══════╝    ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
 *
 */

create function auth.throw_no_access(_tenant_id int, _username text)
    returns void
    language plpgsql
as
$$
begin
    raise exception 'User(username: %) has no access to tenant(id: %)', _username, _tenant_id
        using errcode = 50004;
end;
$$;

create function auth.throw_no_permission(_tenant_id int, _user_id bigint, _perm_codes text[])
    returns void
    language plpgsql
as
$$
begin
    raise exception 'User(id: %) has no permission (codes: %) in tenant(id: %)', _user_id, array_to_string(_perm_codes, '; '), _tenant_id
        using errcode = 50003;
end;
$$;

create function auth.throw_no_permission(_tenant_id int, _user_id bigint, _perm_code text)
    returns void
    language plpgsql
as
$$
begin
    perform auth.throw_no_permission(_tenant_id, _user_id, array [_perm_code]);
end;
$$;

create or replace function unsecure.clear_permission_cache(_deleted_by text, _tenant_id int, _target_user_id bigint)
    returns void
    language sql
as
$$

delete
from auth.user_permission_cache
where tenant_id = _tenant_id
  and user_id = _target_user_id;
$$;

create or replace function unsecure.recalculate_user_groups(_created_by text,
                                                            _target_user_id bigint, _provider_code text)
    returns table
            (
                __groups text[]
            )
    language plpgsql
as
$$
declare
    __not_really_used int;
    __provider_groups text[];
    __provider_roles  text[];
begin

    select provider_groups, provider_roles
    from user_identity
    where provider_code = _provider_code
      and user_id = _target_user_id
    into __provider_groups, __provider_roles;

    -- cleanup membership of groups user is no longer part of
    with affected_deleted_group_tenants as (
        delete
            from user_group_member
                where user_id = _target_user_id
                    and mapping_id is not null
                    and group_id not in (select distinct ugm.group_id
                                         from unnest(__provider_groups) g
                                                  inner join public.user_group_mapping ugm
                                                             on ugm.provider_code = _provider_code and ugm.mapped_object_id = lower(g)
                                                  inner join user_group u
                                                             on u.user_group_id = ugm.group_id
                                         union
                                         select distinct ugm.group_id
                                         from unnest(__provider_roles) r
                                                  inner join public.user_group_mapping ugm
                                                             on ugm.provider_code = _provider_code and ugm.mapped_role = lower(r)
                                                  inner join user_group u
                                                             on u.user_group_id = ugm.group_id)
                returning group_id),
         affected_group_tenants as (
             insert
                 into user_group_member (created_by, user_id, group_id, mapping_id, manual_assignment)
                     select distinct _created_by, _target_user_id, ugm.group_id, ugm.ug_mapping_id, false
                     from unnest(__provider_groups) g
                              inner join public.user_group_mapping ugm
                                         on ugm.provider_code = _provider_code and ugm.mapped_object_id = lower(g)
                     where ugm.group_id not in (select group_id from user_group_member where user_id = _target_user_id)
                     returning group_id),
         affected_role_tenants as (
             insert into user_group_member (created_by, user_id, group_id, mapping_id, manual_assignment)
                 select distinct _created_by, _target_user_id, ugm.group_id, ugm.ug_mapping_id, false
                 from unnest(__provider_roles) r
                          inner join public.user_group_mapping ugm
                                     on ugm.provider_code = _provider_code and ugm.mapped_role = lower(r)
                 where ugm.group_id not in (select group_id from user_group_member where user_id = _target_user_id)
                 returning group_id),
         all_group_ids as (select group_id
                           from affected_deleted_group_tenants
                           union
                           select group_id
                           from affected_group_tenants
                           union
                           select group_id
                           from affected_role_tenants),
         all_tenants as (select tenant_id
                         from all_group_ids ids
                                  inner join user_group ug on ids.group_id = ug.user_group_id
                         group by tenant_id)
         -- variable not really used, it's there just to avoid 'query has no destination for result data'
    select at.tenant_id
    from all_tenants at,
         lateral unsecure.clear_permission_cache(_created_by, at.tenant_id, _target_user_id) r
    into __not_really_used;

    return query
        select array_agg(distinct ug.code)
        from user_group_member ugm
                 inner join user_group ug on ug.user_group_id = ugm.group_id
        where user_id = _target_user_id;
end;
$$;

create or replace function unsecure.recalculate_user_permissions(_created_by text, _tenant_id int, _target_user_id bigint)
    returns table
            (
                __groups      text[],
                __permissions text[]
            )
    language plpgsql
as
$$
declare
    __perm_cache_timeout_in_s bigint;
    __gs                      text[];
    __ps                      text[];
    __expiration_date         timestamptz;
begin

    if exists(select
              from auth.user_permission_cache
              where tenant_id = _tenant_id
                and user_id = _target_user_id
                and expiration_date > now()) then

        return query
            select upc.groups,
                   upc.permissions
            from auth.user_permission_cache upc
            where upc.tenant_id = _tenant_id
              and upc.user_id = _target_user_id;

    else

        select number_value
        from const.sys_params sp
        where sp.group_code = 'auth'
          and sp.code = 'perm_cache_timeout_in_s'
        into __perm_cache_timeout_in_s;

        if (__perm_cache_timeout_in_s is null) then
            __perm_cache_timeout_in_s := 300;
        end if;

        with ugs as (select user_group_id, group_code
                     from user_groups
                     where (tenant_id = _tenant_id or tenant_id is null)
                       and user_id = _target_user_id),
             group_assignments as (select distinct ep.permission_code as full_code
                                   from ugs ug
                                            inner join permission_assignment pa on ug.user_group_id = pa.group_id
                                            inner join effective_permissions ep on pa.perm_set_id = ep.perm_set_id
                                   where ep.perm_set_is_assignable = true
                                     and ep.permission_is_assignable = true
                                   union
                                   select distinct sp.full_code
                                   from ugs ug
                                            inner join permission_assignment pa on ug.user_group_id = pa.group_id
                                            inner join auth.permission p on pa.permission_id = p.permission_id
                                            inner join auth.permission sp
                                                       on sp.node_path <@ p.node_path and sp.is_assignable = true),
             user_assignments as (select distinct ep.permission_code as full_code
                                  from permission_assignment pa
                                           inner join effective_permissions ep on pa.perm_set_id = ep.perm_set_id
                                  where (pa.tenant_id = _tenant_id or pa.tenant_id is null)
                                    and pa.user_id = _target_user_id
                                    and ep.perm_set_is_assignable = true
                                    and ep.permission_is_assignable = true
                                  union
                                  select distinct sp.full_code
                                  from permission_assignment pa
                                           inner join auth.permission p
                                                      on pa.permission_id = p.permission_id
                                           inner join auth.permission sp
                                                      on sp.node_path <@ p.node_path and sp.is_assignable = true
                                  where (pa.tenant_id = _tenant_id or pa.tenant_id is null)
                                    and pa.user_id = _target_user_id),
             user_permissions as (select distinct full_code
                                  from group_assignments
                                  union
                                  select full_code
                                  from user_assignments
                                  order by full_code)
        select coalesce(array_agg(distinct ugs.group_code), array []::text[])                   rs,
               coalesce(array_agg(distinct user_permissions.full_code::text), array []::text[]) ps
        from ugs,
             user_permissions
        into __gs, __ps;

        __expiration_date := now() + interval '1 second' * __perm_cache_timeout_in_s;

        if not exists(select from auth.user_permission_cache upc where upc.user_id = _target_user_id) then
            insert into auth.user_permission_cache (created_by, user_id, tenant_id, groups, permissions, expiration_date)
            values (_created_by, _target_user_id, _tenant_id, __gs, __ps, __expiration_date);
        else
            update auth.user_permission_cache upc
            set modified        = now(),
                modified_by     = _created_by,
                groups          = __gs,
                permissions     = __ps,
                expiration_date = __expiration_date
            where tenant_id = _tenant_id
              and user_id = _target_user_id;
        end if;

        return query
            select __gs, __ps;
    end if;
end;
$$;

create or replace function auth.has_permissions(_tenant_id int, _target_user_id bigint, _perm_codes text[],
                                                _throw_err bool default true)
    returns bool
    language plpgsql
    stable
as
$$
declare
    __perms                   text[];
    __expiration_date         timestamptz;
    __last_used_provider_code text;
begin

    if (_target_user_id = 1) then
        return true;
    end if;

    select permissions, expiration_date
    from auth.user_permission_cache upc
    where upc.tenant_id = _tenant_id
      and user_id = _target_user_id
    into __perms, __expiration_date;

    if __expiration_date is null or __expiration_date <= now() then

        select last_used_provider_code
        from user_info
        where user_id = _target_user_id
        into __last_used_provider_code;

        perform unsecure.recalculate_user_groups('permission_check'
            , _target_user_id
            , __last_used_provider_code
            );

        select __permissions
        from unsecure.recalculate_user_permissions('permission_check', _tenant_id, _target_user_id)
        into __perms;

    end if;

    if exists(
            select
            from unnest(__perms) p
                     inner join unnest(_perm_codes) rp on p = rp
        ) then
        return true;
    end if;

    --     if exists(
--             select p.code, ugm.user_id, p.node_path
--             from user_group ug
--                      inner join permission_assignment uga
--                                 on ug.user_group_id = uga.group_id and ug.tenant_id = _tenant_id
--                      inner join user_group_member ugm on ugm.group_id = uga.group_id
--                      inner join auth.perm_set ps on ps.perm_set_id = uga.perm_set_id
--                      inner join auth.perm_set_perm psp on ps.perm_set_id = psp.perm_set_id
--                      inner join auth.permission p on p.permission_id = psp.permission_id
--                      inner join (select unnest as code from unnest(_perm_codes)) pc
--                                 on p.full_code @> ext.text2ltree(pc.code)
--             where (ug.tenant_id = _tenant_id or ug.tenant_id is null)
--               and ugm.user_id = _target_user_id
--         ) then
--         return true;
--     end if;

    if (_throw_err) then

        perform add_journal_msg('system', _tenant_id, _target_user_id
            , format('User: (id: %s) has no permission: %s'
                                    , _target_user_id, array_to_string(_perm_codes, '; '))
            , 'perm', _target_user_id
            , _event_id := 50003);

        perform auth.throw_no_permission(_tenant_id, _target_user_id, _perm_codes);
    end if;

    return false;
end ;
$$;

create or replace function auth.has_permission(_tenant_id int, _target_user_id bigint, _perm_code text,
                                               _throw_err bool default true)
    returns bool
    language plpgsql
    stable
as
$$
begin
    return auth.has_permissions(_tenant_id, _target_user_id, array [_perm_code], _throw_err);
end ;
$$;


create function unsecure.create_primary_tenant()
    returns setof tenant
    language sql
    rows 1
as
$$
insert into tenant(created_by, modified_by, name, code, is_removable, is_assignable)
values ('initial_script', 'initial_script', 'Primary', 'primary', false, true)
returning *;
$$;


create function unsecure.create_system_user()
    returns setof user_info
    language sql
    rows 1
as
$$
insert into user_info(created_by, modified_by, can_login, email, display_name, username)
values ('initial_script', 'initial_script', false, 'system', 'System', 'system')
returning *;

$$;

create function unsecure.delete_user_by_username_as_system(_username text)
    returns user_info
    language sql
as
$$
delete
from user_info
where lower(username) = lower(_username)
returning *;

$$;

create function auth.validate_provider_is_active(_provider_code text)
    returns void
    language plpgsql
as
$$
begin
    if exists(select from auth.provider where code = _provider_code and is_active = false) then
        raise exception 'Provider (provider code: %) is not active', _provider_code
            using errcode = 52107;
    end if;
end;
$$;


/***
 *    ██████╗ ██████╗  ██████╗ ██╗   ██╗██╗██████╗ ███████╗██████╗ ███████╗
 *    ██╔══██╗██╔══██╗██╔═══██╗██║   ██║██║██╔══██╗██╔════╝██╔══██╗██╔════╝
 *    ██████╔╝██████╔╝██║   ██║██║   ██║██║██║  ██║█████╗  ██████╔╝███████╗
 *    ██╔═══╝ ██╔══██╗██║   ██║╚██╗ ██╔╝██║██║  ██║██╔══╝  ██╔══██╗╚════██║
 *    ██║     ██║  ██║╚██████╔╝ ╚████╔╝ ██║██████╔╝███████╗██║  ██║███████║
 *    ╚═╝     ╚═╝  ╚═╝ ╚═════╝   ╚═══╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚══════╝
 *
 */

create function auth.create_provider(_created_by text, _user_id bigint, _provider_code text, _provider_name text,
                                     _is_active bool default true)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    perform auth.has_permission(null, _user_id, 'system.providers.create_provider');

    insert into provider (created_by, modified_by, code, name, is_active)
    values (_created_by, _created_by, _provider_code, _provider_name, _is_active)
    returning provider_id into __last_id;

    return query
        select __last_id;

    perform add_journal_msg(_created_by, null, _user_id
        , format('User: %s created new authentication provider: %s'
                                , _created_by, _provider_name)
        , 'provider', __last_id
        , array ['provider_code', _provider_code, 'provider_name', _provider_name, 'is_active', _is_active::text]
        , 50011);
end;
$$;

create function auth.update_provider(_modified_by text, _user_id bigint, _provider_id int, _provider_code text,
                                     _provider_name text,
                                     _is_active bool default true)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
begin

    perform auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update provider
            set
                modified = now(),
                modified_by = _modified_by,
                code = _provider_code,
                name = _provider_name,
                is_active = _is_active
            where provider_id = _provider_id
            returning provider_id;

    perform add_journal_msg(_modified_by, null, _user_id
        , format('User: %s updated authentication provider: %s'
                                , _modified_by, _provider_name)
        , 'provider', _provider_id
        , array ['provider_code', _provider_code, 'provider_name', _provider_name, 'is_active', _is_active::text]
        , 50012);
end;
$$;

create function auth.delete_provider(_deleted_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __user_id      bigint,
                __username     text,
                __display_name text
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform auth.has_permission(null, _user_id, 'system.providers.delete_provider');

    return query
        delete from auth.provider where code = _provider_code
            returning __provider_id;

    perform add_journal_msg(_deleted_by, null, _user_id
        , format('User: %s deleted authentication provider: %s'
                                , _deleted_by, _provider_code)
        , 'provider', __provider_id
        , null
        , 50013);
end;
$$;

create function auth.get_users_by_provider(_requested_user text, _user_id bigint, _provider_code text)
    returns table
            (
                __user_id          bigint,
                __user_identity_id bigint,
                __username         text,
                __display_name     text
            )
    language plpgsql
as
$$
declare
    __provider_id int;
begin
    perform auth.has_permission(null, _user_id, 'system.providers.get_users');

    select provider_id
    from auth.provider
    where code = _provider_code
    into __provider_id;

    return query
        select ui.user_id, uid.user_identity_id, ui.username, ui.display_name
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = _provider_code
        order by ui.display_name;

    perform add_journal_msg(_requested_user, null, _user_id
        , format('User: %s requested a list of all users for authentication provider: %s'
                                , _requested_user, _provider_code)
        , 'provider', __provider_id
        , null
        , 50016);
end;
$$;


create function auth.enable_provider(_modified_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update auth.provider
            set is_active = true
            where code = _provider_code
            returning provider_id;

    perform add_journal_msg(_modified_by, null, _user_id
        , format('User: %s enabled authentication provider: %s'
                                , _modified_by, _provider_code)
        , 'provider', __provider_id
        , null
        , 50014);
end;
$$;

create function auth.disable_provider(_modified_by text, _user_id bigint, _provider_code text)
    returns table
            (
                __provider_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __provider_id int;
begin

    perform auth.has_permission(null, _user_id, 'system.providers.update_provider');

    return query
        update provider
            set is_active = false
            where code = _provider_code
            returning provider_id;

    perform add_journal_msg(_modified_by, null, _user_id
        , format('User: %s disabled authentication provider: %s'
                                , _modified_by, _provider_code)
        , 'provider', __provider_id
        , null
        , 50015);
end;
$$;


/***
 *     ██████╗ ██████╗  ██████╗ ██╗   ██╗██████╗ ███████╗
 *    ██╔════╝ ██╔══██╗██╔═══██╗██║   ██║██╔══██╗██╔════╝
 *    ██║  ███╗██████╔╝██║   ██║██║   ██║██████╔╝███████╗
 *    ██║   ██║██╔══██╗██║   ██║██║   ██║██╔═══╝ ╚════██║
 *    ╚██████╔╝██║  ██║╚██████╔╝╚██████╔╝██║     ███████║
 *     ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝
 *
 */


create function unsecure.add_user_group_member(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                               _target_user_id bigint)
    returns table
            (
                __user_group_member_id bigint
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_assignable bool;
    __is_external   bool;
    __is_active     bool;
begin

    select is_assignable, is_external, is_active
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_assignable, __is_external, __is_active;

    if __is_active is null then
        raise exception 'User group (group id: %) does not exist'
            , _user_group_id
            using errcode = 52171;
    end if;

    if not __is_active then
        raise exception 'User group (group id: %) is not active'
            , _user_group_id
            using errcode = 52172;
    end if;

    raise notice 'Is assignable: %, is external: %'
        , __is_assignable, __is_external;

    if not __is_assignable or __is_external then
        raise exception 'User group (group id: %) is either is not assignable or is external'
            , _user_group_id
            using errcode = 52173;
    end if;

    return query
        insert into user_group_member (created_by, group_id, user_id, manual_assignment)
            values (_created_by, _user_group_id, _target_user_id, true)
            returning member_id;

    perform add_journal_msg(_created_by, _tenant_id, _user_id
        , format('User: %s added new user: %s to group: %s in tenant: %s'
                                , _created_by, _target_user_id, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , array ['target_user_id', _target_user_id::text]
        , 50131);
end;
$$;

create function unsecure.add_user_to_group_as_system(_user_name text, _group_title text, _tenant_id int default null)
    returns setof user_group_member
    language plpgsql
as

$$
declare
    __user_id  bigint;
    __group_id int;
begin
    select ui.user_id
    from user_info ui
    where ui.username = _user_name
    into __user_id;

    select user_group_id
    from user_group ug
    where lower(ug.title) = lower(_group_title)
    into __group_id;

    return query
        select ugm.*
        from unsecure.add_user_group_member('system', 1, _tenant_id, __group_id, __user_id) r
                 inner join user_group_member ugm on ugm.member_id = r.__user_group_member_id;
end;
$$;

create function unsecure.assign_permission(_created_by text, _user_id bigint, _tenant_id int,
                                           _user_group_id int default null,
                                           _target_user_id bigint default null,
                                           _perm_set_code text default null, _perm_code text default null)
    returns setof permission_assignment
    language plpgsql
as
$$
declare
    __last_id               int;
    __perm_set_id           int;
    __perm_set_assignable   bool;
    __permission_id         int;
    __permission_assignable bool;
begin

    if _user_group_id is null and _target_user_id is null then
        raise exception 'Either user group is or target user id must not be null'
            using errcode = 52272;
    end if;

    if _perm_set_code is null and _perm_code is null then
        raise exception 'Either user group is or target user id must not be null'
            using errcode = 52273;
    end if;

    if _user_group_id is not null and not exists(select
                                                 from user_group ug
                                                 where ug.user_group_id = _user_group_id) then
        raise exception 'User group (group id: %) does not exist'
            , _user_group_id
            using errcode = 52171;
    end if;

    if _target_user_id is not null and not exists(select
                                                  from user_info ui
                                                  where ui.user_id = _target_user_id) then
        raise exception 'User (user id: %) does not exist'
            , _user_group_id
            using errcode = 52103;
    end if;

    if _perm_set_code is not null then
        select perm_set_id, is_assignable
        from auth.perm_set
        where code = _perm_set_code
        into __perm_set_id, __perm_set_assignable;

        if __perm_set_id is null then
            raise exception 'Permission set (code: %) is not assignable'
                , _perm_set_code
                using errcode = 52175;
        end if;
    end if;

    if _perm_code is not null then
        select permission.permission_id, is_assignable
        from auth.permission
        where code = _perm_code
        into __permission_id, __permission_assignable;

        if __permission_id is null then
            raise exception 'Permission (code: %) is not assignable'
                , _perm_set_code
                using errcode = 52176;
        end if;
    end if;

    insert into permission_assignment (created_by, tenant_id, group_id, user_id, perm_set_id, permission_id)
    values (_created_by, _tenant_id, _user_group_id, _user_id, __perm_set_id, __permission_id)
    returning assignment_id into __last_id;

    return query
        select * from permission_assignment where assignment_id = __last_id;

    if _user_group_id is not null then
        perform add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s assigned new permission: %s to group: %s in tenant: %s'
                                    , _created_by, coalesce(_perm_set_code, _perm_code), _user_group_id, _tenant_id)
            , 'group', _user_group_id
            , array ['assignment_id', __last_id::text, 'perm_set_code', _perm_set_code, 'permission_code', _perm_code]
            , 50304);
    else
        perform add_journal_msg(_created_by, _tenant_id, _user_id
            , format('User: %s assigned new permission: %s to user: %s in tenant: %s'
                                    , _created_by, coalesce(_perm_set_code, _perm_code), _target_user_id, _tenant_id)
            , 'user', _target_user_id
            , array ['assignment_id', __last_id::text, 'perm_set_code', _perm_set_code, 'permission_code', _perm_code]
            , 50304);
    end if;
end;
$$;

create function unsecure.unassign_permission(_deleted_by text, _user_id bigint, _tenant_id int,
                                             _assignment_id int)
    returns setof permission_assignment
    language plpgsql
as
$$
declare
    __user_group_id  int;
    __target_user_id int;
begin

    select group_id, user_id
    from permission_assignment pa
    where pa.assignment_id = _assignment_id
    into __user_group_id, __target_user_id;

    return query
        delete from permission_assignment
            where assignment_id = _assignment_id
            returning *;

    if __user_group_id is not null then
        perform add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s unassigned permission from group: %s in tenant: %s'
                                    , _deleted_by, __user_group_id, _tenant_id)
            , 'group', __user_group_id
            , array ['assignment_id', _assignment_id::text]
            , 50305);
    else
        perform add_journal_msg(_deleted_by, _tenant_id, _user_id
            , format('User: %s unassigned permission from user: %s in tenant: %s'
                                    , _deleted_by, __user_group_id, _tenant_id)
            , 'user', __target_user_id
            , array ['assignment_id', _assignment_id::text]
            , 50304);
    end if;
end;

$$;

create function unsecure.set_permission_as_assignable(_modified_by text, _user_id bigint,
                                                      _permission_id int default null,
                                                      _permission_full_code text default null,
                                                      _is_assignable bool default true)
    returns setof permission_assignment
    language plpgsql
as
$$
declare
    __permission_id        int;
    __permission_full_code text;
begin

    if _permission_id is null and _permission_full_code is null then
        raise exception 'Either permission id or code has to be not null'
            using errcode = 52274;
    end if;

    __permission_id := _permission_id;

    if __permission_id is null then
        select permission_id from permission where full_code = _permission_full_code into __permission_id;

        if __permission_id is null then
            raise exception 'Permission (full code: %s) does not exist'
                , _permission_full_code
                using errcode = 52275;
        end if;
    end if;

    update permission
    set modified      = now(),
        modified_by   = _modified_by,
        is_assignable = _is_assignable
    where permission_id = __permission_id
    returning full_code into __permission_full_code;

    perform add_journal_msg(_modified_by, null, _user_id
        , format('User: %s set permission: %s as assignable: %s'
                                , _modified_by, __permission_full_code, _is_assignable)
        , 'permission', __permission_id
        , null
        , 50306);
end;
$$;

create function auth.set_permission_as_assignable(_modified_by text, _user_id bigint,
                                                  _permission_id int default null,
                                                  _permission_full_code text default null,
                                                  _is_assignable bool default true)
    returns setof permission_assignment
    language plpgsql
as
$$
begin
    perform has_permission(null, _user_id, 'system.manage_permissions.update_permission');

    return query
        select *
        from unsecure.set_permission_as_assignable(_modified_by, _user_id, _permission_id, _permission_full_code,
                                                   _is_assignable);
end;
$$;


create function unsecure.assign_permission_as_system(_tenant_id int, _user_group_id int, _target_user_id bigint,
                                                     _perm_set_code text,
                                                     _perm_code text default null)
    returns setof permission_assignment
    language plpgsql
as
$$
begin
    return query
        select *
        from unsecure.assign_permission('system', 1, _tenant_id, _user_group_id, _target_user_id, _perm_set_code,
                                        _perm_code);
end;

$$;

create function auth.assign_permission(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                       _target_user_id bigint,
                                       _perm_set_code text,
                                       _perm_code text)
    returns setof permission_assignment
    language plpgsql
as
$$
begin
    perform has_permission(_tenant_id, _user_id, 'system.manage_permissions.assign_permission');

    return query
        select *
        from unsecure.assign_permission(_created_by, _user_id, _tenant_id
            , _user_group_id, _target_user_id
            , _perm_set_code
            , _perm_code);
end;

$$;

create function auth.unassign_permission(_deleted_by text, _user_id bigint, _tenant_id int, _assignment_id int)
    returns setof permission_assignment
    language plpgsql
as
$$
begin
    perform has_permission(_tenant_id, _user_id, 'system.manage_permissions.unassign_permission');

    return query
        select *
        from unsecure.unassign_permission(_deleted_by, _user_id, _tenant_id, _assignment_id);
end;
$$;

create function public.assign_tenant_owner(_created_by text, _user_id bigint, _tenant_id int, _target_user_id bigint)
    returns setof user_group_member
    language plpgsql
    rows 1
as
$$
declare
    __ug_id int;
begin
    perform auth.has_permission(1, _user_id, 'system.manage_tenants.assign_owner');

    select ug.user_group_id
    from user_group ug
    where ug.tenant_id = _tenant_id
      and ug.code = 'tenant_owners'
    into __ug_id;

    return query
        select ugm.*
        from unsecure.add_user_group_member(_created_by, _user_id
                 , _tenant_id, __ug_id, _target_user_id) r
                 inner join user_group_member ugm on ugm.member_id = r.__user_group_member_id;

    perform add_journal_msg(_created_by, _tenant_id, _user_id
        , format('User: %s assigned new owner: %s to tenant: %s'
                                , _created_by, _target_user_id, _tenant_id)
        , 'tenant', _tenant_id
        , array ['target_user_id', _target_user_id::text]
        , 50004);
end;
$$;

create function unsecure.create_user_group(_created_by text, _user_id bigint, _title text
    , _tenant_id int default null, _is_assignable bool default true, _is_active bool default true,
                                           _is_external bool default false,
                                           _is_system bool default false, _is_default bool default false)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    insert into user_group (created_by, modified_by, tenant_id, title, is_default, is_system, is_assignable,
                            is_active, is_external)
    values (_created_by, _created_by, _tenant_id, _title, _is_default, _is_system, _is_assignable, _is_active,
            _is_external)
    returning user_group_id into __last_id;

    return query
        select __last_id;

    perform add_journal_msg(_created_by, _tenant_id, _user_id
        , format('User: %s added new group: %s in tenant: %s'
                                , _created_by, _title, _tenant_id)
        , 'group', __last_id
        ,
                            array ['title', _title, 'is_default', _is_default::text
                                , 'is_system', _is_system::text
                                , 'is_assignable', _is_assignable::text
                                , 'is_active', _is_active::text]
        , 50201);

end ;
$$;

create function unsecure.create_user_group_as_system(_tenant_id int, _title text
, _is_system bool default false, _is_assignable bool default true)
    returns setof user_group
    language sql
    rows 1
as
$$
select ug.*
from unsecure.create_user_group('system', 1, _title, _tenant_id, _is_assignable, true, false, _is_system) g
         inner join user_group ug on ug.user_group_id = g.__group_id ;

$$;

create function auth.create_user_group(_created_by text, _user_id bigint, _title text, _tenant_id int,
                                       _is_assignable bool default true, _is_active bool default true,
                                       _is_external bool default false)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permissions(_tenant_id, _user_id,
                                 array ['system.manage_groups.create_group']);

    return query
        select *
        from unsecure.create_user_group(_created_by, _user_id, _title, _tenant_id
            , _is_assignable, _is_active, _is_external, false,
                                        false);
end ;
$$;

create function auth.update_user_group(_modified_by text, _user_id bigint, _tenant_id int, _ug_id int, _title text,
                                       _is_assignable bool, _is_active bool)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , title = _title
                , is_assignable = _is_assignable
                , is_active = _is_active
            where tenant_id = _tenant_id
                and user_group_id = _ug_id
            returning user_group_id;
end;
$$;

create function auth.enable_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_active = true
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s enabled user group: %s in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50204);
end;
$$;

create function auth.disable_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_active = false
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s disabled user group: %s in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50205);
end;
$$;

create function auth.lock_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.lock_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_assignable = false
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s enabled user group: %s in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50207);
end;
$$;

create function auth.unlock_user_group(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id      int,
                __is_active     bool,
                __is_assignable bool,
                __modified      timestamptz,
                __modified_by   text
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    return query
        update user_group
            set modified_by = _modified_by
                , modified = now()
                , is_assignable = true
            where tenant_id = _tenant_id
                and user_group_id = _user_group_id
            returning user_group_id
                , is_active
                , is_assignable
                , modified
                , modified_by;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s disabled user group: %s in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50206);
end;
$$;


create function auth.delete_user_group(_deleted_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_system bool;
begin

    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.delete_group');

    select is_system, tenant_id
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_system;

    if __is_system is null then
        raise exception 'User: group (group id: %) does not exist'
            , _user_group_id
            using errcode = 52171;
    end if;

    if not __is_system then
        raise exception 'User: group (group id: %) is a system group'
            , _user_group_id
            using errcode = 52271;
    end if;

    return query
        delete
            from user_group
                where tenant_id = _tenant_id
                    and user_group_id = _user_group_id;

    perform add_journal_msg(_deleted_by, _tenant_id, _user_id
        , format('User: %s removed user group: %s in tenant: %s'
                                , _deleted_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50203);
end;
$$;

create function auth.create_user_group_member(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                              _target_user_id int)
    returns table
            (
                __user_group_member_id bigint
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.create_member');

    return query
        select *
        from unsecure.add_user_group_member(_created_by, _user_id, _tenant_id, _user_group_id, _target_user_id);
end;
$$;

create function auth.delete_user_group_member(_deleted_by text, _user_id bigint, _tenant_id int, _ug_id int,
                                              _user_member_id bigint)
    returns void
    language plpgsql
as
$$
declare
    __target_user_id int;
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.delete_member');

    delete
    from user_group_member
    where group_id = _ug_id
      and member_id = _user_member_id
    returning user_id into __target_user_id;

    perform add_journal_msg(_deleted_by, _tenant_id, _user_id
        , format('User: %s removed user: %s from group: %s in tenant: %s'
                                , _deleted_by, __target_user_id, _ug_id, _tenant_id)
        , 'group', _ug_id
        , array ['target_user_id', __target_user_id::text]
        , 50133);
end;
$$;

create function auth.create_user_group_mapping(_created_by text, _user_id bigint, _tenant_id int, _user_group_id int,
                                               _provider_code text,
                                               _mapped_object_id text default null,
                                               _mapped_object_name text default null,
                                               _mapped_role text default null)
    returns table
            (
                __ug_mapping_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __is_group_active bool;
begin

    if _mapped_object_id is null and _mapped_role is null then
        raise exception 'Either mapped object id or mapped role must not be empty'
            using errcode = 52174;
    end if;

    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.create_mapping');

    select is_active, tenant_id
    from user_group ug
    where ug.user_group_id = _user_group_id
    into __is_group_active;

    if __is_group_active is null then
        raise exception 'User group (group id: %) does not exist'
            , _user_group_id
            using errcode = 52171;
    end if;

    return query
        insert into user_group_mapping (created_by, group_id, provider_code, mapped_object_id, mapped_object_name,
                                        mapped_role)
            values (_created_by, _user_group_id, _provider_code, lower(_mapped_object_id), _mapped_object_name,
                    lower(_mapped_role))
            returning ug_mapping_id;

    perform add_journal_msg(_created_by, _tenant_id, _user_id
        , format('User: %s added new provider: %s mapping: %s to group: %s in tenant: %s'
                                , _created_by, _provider_code, coalesce(_mapped_object_id, _mapped_role),
                 _user_group_id, _tenant_id)
        , 'group', _user_group_id
        ,
                            array ['mapped_object_id', _mapped_object_id::text, 'mapped_object_name'
                                , _mapped_object_name, '_mapped_role', _mapped_role]
        , 50231);
end;
$$;

create function auth.delete_user_group_mapping(_deleted_by text, _user_id bigint, _tenant_id int, _ug_id int,
                                               _ug_mapping_id int)
    returns void
    language plpgsql
as
$$
declare
    __mapped_object_id   text;
    __mapped_object_name text;
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.delete_mapping');

    delete
    from user_group_mapping
    where group_id = _ug_id
      and ug_mapping_id = _ug_mapping_id
    returning mapped_object_id, mapped_object_name into __mapped_object_id, __mapped_object_name;


    perform add_journal_msg(_deleted_by, _tenant_id, _user_id
        , format('User: %s removed group mapping: %s from group: %s in tenant: %s'
                                , _deleted_by, __mapped_object_name, _ug_id, _tenant_id)
        , 'group', _ug_id
        , array ['mapped_object_id', __mapped_object_id::text, 'mapped_object_name', __mapped_object_name]
        , 50233);
end;
$$;


create function auth.create_external_user_group(_created_by text, _user_id bigint, _title text, _tenant_id int,
                                                _provider text,
                                                _is_assignable bool default true, _is_active bool default true,
                                                _mapped_object_id text default null,
                                                _mapped_object_name text default null,
                                                _mapped_role text default null)
    returns table
            (
                __group_id int
            )
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin
    perform auth.has_permissions(_tenant_id, _user_id,
                                 array ['system.manage_groups.create_group']);


    select *
    from unsecure.create_user_group(_created_by, _user_id, _title, _tenant_id
        , _is_assignable, _is_active, true,
                                    false)
    into __last_id;

    perform auth.create_user_group_mapping(_created_by, _user_id, _tenant_id, __last_id, _provider, _mapped_object_id,
                                           _mapped_object_name, _mapped_role);

    return query
        select __last_id;
end ;
$$;

create function auth.set_user_group_as_external(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns void
    language plpgsql
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    delete
    from user_group_member ugm
    where ugm.group_id = _user_group_id
      and ugm.manual_assignment = true;

    update user_group
    set modified    = now(),
        modified_by = _modified_by,
        is_external = true
    where user_group_id = _user_group_id;


    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s set user group as external in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50208);
end;
$$;

create function auth.set_user_group_as_hybrid(_modified_by text, _user_id bigint, _tenant_id int, _user_group_id int)
    returns void
    language plpgsql
as
$$
begin
    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_groups.update_group');

    update user_group
    set modified    = now(),
        modified_by = _modified_by,
        is_external = false
    where user_group_id = _user_group_id;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s set user group as hybrid in tenant: %s'
                                , _modified_by, _user_group_id, _tenant_id)
        , 'group', _user_group_id
        , null
        , 50209);
end;
$$;


/***
 *    ######## ######## ##    ##    ###    ##    ## ########  ######
 *       ##    ##       ###   ##   ## ##   ###   ##    ##    ##    ##
 *       ##    ##       ####  ##  ##   ##  ####  ##    ##    ##
 *       ##    ######   ## ## ## ##     ## ## ## ##    ##     ######
 *       ##    ##       ##  #### ######### ##  ####    ##          ##
 *       ##    ##       ##   ### ##     ## ##   ###    ##    ##    ##
 *       ##    ######## ##    ## ##     ## ##    ##    ##     ######
 */


create function public.create_tenant(_created_by text, _user_id bigint, _name text, _code text default null,
                                     _is_removable bool default true, _is_assignable bool default true,
                                     _tenant_owner_id bigint default null)
    returns setof tenant
    language plpgsql
    rows 1
as
$$
declare
    __last_id               int;
    __tenant_owner_group_id int;
begin
    perform auth.has_permission(1, _user_id, 'system.manage_tenants.create_tenant');

    insert into tenant (created_by, modified_by, name, code, is_removable, is_assignable)
    values (_created_by, _created_by, _name, coalesce(_code, helpers.get_code(_name)), _is_removable,
            _is_assignable)
    returning tenant_id into __last_id;

    perform add_journal_msg(_created_by, __last_id, _user_id
        , format('User: %s created new tenant: %s'
                                , _created_by, _name)
        , 'tenant', __last_id
        , array ['title', _name]
        , 50001);

    select __group_id
    from unsecure.create_user_group(_created_by, _user_id, 'Tenant Owners'
        , __last_id, true, true, false, true)
    into __tenant_owner_group_id;

    perform unsecure.assign_permission(_created_by, _user_id
        , __last_id, __tenant_owner_group_id, null, 'tenant_owner');

    if (_tenant_owner_id is not null) then
        perform unsecure.add_user_group_member(_created_by, _user_id, __last_id, __tenant_owner_group_id,
                                               _tenant_owner_id);
    end if;

    return query
        select * from tenant where tenant_id = __last_id;
end;
$$;


/***
 *    ########  ######## ########  ##     ## ####  ######   ######  ####  #######  ##    ##  ######
 *    ##     ## ##       ##     ## ###   ###  ##  ##    ## ##    ##  ##  ##     ## ###   ## ##    ##
 *    ##     ## ##       ##     ## #### ####  ##  ##       ##        ##  ##     ## ####  ## ##
 *    ########  ######   ########  ## ### ##  ##   ######   ######   ##  ##     ## ## ## ##  ######
 *    ##        ##       ##   ##   ##     ##  ##        ##       ##  ##  ##     ## ##  ####       ##
 *    ##        ##       ##    ##  ##     ##  ##  ##    ## ##    ##  ##  ##     ## ##   ### ##    ##
 *    ##        ######## ##     ## ##     ## ####  ######   ######  ####  #######  ##    ##  ######
 */

create function unsecure.update_permission_full_title(_perm_path ext.ltree) returns SETOF auth.permission
    language sql
    rows 1
as
$$
update auth.permission p
set full_title =
        case
            when _perm_path = '1'::ext.ltree then 'System'
            else
                (select array_to_string(
                                ARRAY(SELECT p_n2.title
                                      FROM auth.permission as p_n2
                                      WHERE p_n2.node_path @> p_n.node_path
                                        and p_n2.permission_id <> 1
                                      ORDER BY p_n2.node_path),
                                ' > ')
                 FROM auth.permission As p_n
                 where p_n.permission_id = p.permission_id)
            end
where p.node_path <@ _perm_path
returning *;
$$;

create function unsecure.update_permission_full_code(_perm_path ext.ltree) returns SETOF auth.permission
    language sql
    rows 1
as
$$
update auth.permission p
set full_code = (select ext.text2ltree(array_to_string(
        ARRAY(SELECT coalesce(p_n2.code, helpers.get_code(p_n2.title, '_'))
              FROM auth.permission as p_n2
              WHERE p_n2.node_path @> p_n.node_path
              ORDER BY p_n2.node_path),
        '.'))
                 FROM auth.permission As p_n
                 where p_n.permission_id = p.permission_id)
where p.node_path <@ _perm_path
returning *;
$$;

create or replace function unsecure.create_permission_by_path_as_system(_title text
, _parent_code text default ''
, _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id     int;
    __p           ext.ltree;
    __parent_id   int;
    __parent_path text;
begin

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values ('system', 'system', _title, _is_assignable, helpers.get_code(_title, '_'))
    returning permission_id into __last_id;

    if (_parent_code = '') then
        begin
            if (lower(_title) = 'system') then
                __p := ext.text2ltree(__last_id::text);
            else
                __p := ext.text2ltree('1.' || __last_id::text);
            end if;

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            select p.permission_id, node_path::text
            from auth.permission p
            where p.full_code = ext.text2ltree(_parent_code)
            into __parent_id, __parent_path;

            __p := ext.text2ltree(__parent_path || '.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission set has_children = true where permission_id = __parent_id;
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where node_path = __p;
end;
$$;

create function auth.create_permission_by_path(_created_by text, _user_id int,
                                               _data_node_path text, _title text,
                                               _parent_path text default '',
                                               _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
    __p       ext.ltree;
begin

    perform auth.has_permission(_user_id, _data_node_path::ext.ltree, 'system.manage_permissions.add_permission');

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values (_created_by, _created_by, _title, _is_assignable, helpers.get_code(_title))
    returning permission_id into __last_id;

    if (_parent_path = '') then
        begin
            if (lower(_title) != 'system')
            then
                __p := ext.text2ltree('1.' || __last_id::text);
            else
                __p := ext.text2ltree('1');
            end if;

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            __p := ext.text2ltree(_parent_path || '.' || __last_id::varchar);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission set has_children = true where node_path = ext.text2ltree(_parent_path);
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where permission_id = __last_id;
end;
$$;

create or replace function auth.create_permission_by_code(_created_by text, _user_id int, _title text,
                                                          _parent_code text default '',
                                                          _is_assignable bool default true)
    returns setof auth.permission
    language plpgsql
    rows 1
as
$$
declare
    __last_id     int;
    __p           ext.ltree;
    __parent_id   int;
    __parent_path text;
begin

    perform auth.has_permission(_user_id, 'system.manage_permissions.add_permission');

    insert into auth.permission(created_by, modified_by, title, is_assignable, code)
    values (_created_by, _created_by, _title, _is_assignable, helpers.get_code(_title))
    returning permission_id into __last_id;

    if (_parent_code = '') then
        begin
            __p := ext.text2ltree('1.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;
        end;
    else
        begin
            select p.permission_id, node_path::text
            from auth.permission p
            where p.full_code = ext.text2ltree(_parent_code)
            into __parent_id, __parent_path;

            __p := ext.text2ltree(__parent_path || '.' || __last_id::text);

            update auth.permission
            set node_path = __p
            where permission_id = __last_id;

            update auth.permission set has_children = true where permission_id = __parent_id;
        end;

    end if;

    perform unsecure.update_permission_full_title(__p);
    perform unsecure.update_permission_full_code(__p);

    return query
        select *
        from auth.permission
        where node_path = __p;
end;
$$;


create function unsecure.create_perm_set(
    _created_by text,
    _user_id bigint,
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    if exists(SELECT
              from unnest(_permissions) as perm_code
                       inner join auth.permission p
                                  on p.full_code = perm_code::ext.ltree and not p.is_assignable) then
        raise exception 'Some of permissions are not assignable'
            using errcode = 52176;
    end if;

    -- noinspection SqlInsertValues
    insert into auth.perm_set(created_by, modified_by, tenant_id, title, is_system, is_assignable)
    values ('system', 'system', _tenant_id, _title, _is_system, _is_assignable)
    returning perm_set_id into __last_id;

    insert into auth.perm_set_perm(created_by, perm_set_id, permission_id)
    SELECT 'system', __last_id, p.permission_id
    from unnest(_permissions) as perm_code
             inner join auth.permission p on p.full_code = perm_code::ext.ltree;

    perform add_journal_msg(_created_by, _tenant_id, _user_id
        , format('User: %s created new permission set: %s'
                                , _created_by, _title)
        , 'perm_set', __last_id
        ,
                            array ['title', _title, 'is_system', _is_system::text, 'is_assignable', _is_assignable::text, 'permissions', array_to_string(_permissions, ', ')]
        , 50301);

    return query
        select *
        from auth.perm_set
        where perm_set_id = __last_id;
end;
$$;

create function unsecure.create_perm_set_as_system(
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language sql
    rows 1
as
$$

select *
from unsecure.create_perm_set('system', 1, _title, _tenant_id, _is_system, _is_assignable, _permissions);

$$;

create function auth.create_perm_set(
    _created_by text,
    _user_id text,
    _title text,
    _tenant_id int default null,
    _is_system bool default false,
    _is_assignable bool default true,
    _permissions text[] default null)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
begin

    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.create_permission_set');

    return query
        select *
        from unsecure.create_perm_set(_created_by, _user_id, _title, _tenant_id, _is_system, _is_assignable,
                                      _permissions);
end;
$$;

create function unsecure.update_perm_set(
    _modified_by text,
    _user_id text,
    _tenant_id int,
    _perm_set_id int,
    _title text,
    _is_assignable bool default true
)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
declare
    __last_id int;
begin

    -- noinspection SqlInsertValues
    update perm_set
    set modified      = now(),
        modified_by   = _modified_by,
        title         = _title,
        is_assignable = _is_assignable
    where perm_set_id = _perm_set_id
    returning perm_set_id into __last_id;

    perform add_journal_msg(_modified_by, _tenant_id, _user_id
        , format('User: %s updated permission set: %s'
                                , _modified_by, _title)
        , 'perm_set', __last_id
        ,
                            array ['title', _title, 'is_assignable', _is_assignable::text]
        , 50302);

    return query
        select *
        from auth.perm_set
        where perm_set_id = __last_id;
end;
$$;

create function auth.update_perm_set(
    _modified_by text,
    _user_id text,
    _tenant_id int,
    _perm_set_id int,
    _title text,
    _is_assignable bool default true
)
    returns setof auth.perm_set
    language plpgsql
    rows 1
as
$$
begin

    if not exists(select from auth.perm_set where perm_set_id = _perm_set_id and tenant_id = _tenant_id) then
        raise exception 'Permission set (id: %) is not defined in tenant (id: %)', _perm_set_id, _tenant_id
            using errcode = 52177;
    end if;

    perform auth.has_permission(_tenant_id, _user_id, 'system.manage_permissions.update_permission_set');

    return query
        select *
        from unsecure.update_perm_set(_modified_by, _user_id, _tenant_id
            , _perm_set_id, _title, _is_assignable);
end;
$$;

/***
 *    ##     ##  ######  ######## ########   ######
 *    ##     ## ##    ## ##       ##     ## ##    ##
 *    ##     ## ##       ##       ##     ## ##
 *    ##     ##  ######  ######   ########   ######
 *    ##     ##       ## ##       ##   ##         ##
 *    ##     ## ##    ## ##       ##    ##  ##    ##
 *     #######   ######  ######## ##     ##  ######
 */

create or replace function unsecure.update_last_used_provider(_target_user_id bigint, _provider_code text)
    returns void
    language sql
as
$$
update user_info
set last_used_provider_code = _provider_code
where user_id = _target_user_id;
$$;

create or replace function auth.ensure_groups_and_permissions(_created_by text, _user_id bigint, _target_user_id bigint,
                                                              _tenant_id int,
                                                              _provider_code text,
                                                              _provider_groups text[] default null,
                                                              _provider_roles text[] default null)
    returns table
            (
                __tenant_id   int,
                __groups      text[],
                __permissions text[]
            )
    language plpgsql
    rows 1
as
$$
begin
    perform auth.has_permission(null, _user_id, 'system.authentication.ensure_permissions');

    update user_identity
    set modified_by     = _created_by,
        modified        = now(),
        provider_groups = _provider_groups,
        provider_roles  = _provider_roles
    where provider_code = _provider_code
      and user_id = _target_user_id;

    perform unsecure.recalculate_user_groups(_created_by
        , _target_user_id
        , _provider_code
        );

    return query
        select _tenant_id, up.__groups, up.__permissions
        from unsecure.recalculate_user_permissions(_created_by
                 , _tenant_id, _target_user_id) up;
end;
$$;


-- for email authentication
create or replace function auth.register_user(_created_by text, _user_id int, _email text, _password_hash text,
                                              _display_name text, _user_data text)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text
            )
    language plpgsql
    rows 1
as
$$
declare
    __normalized_email text;
    __new_user         user_info;
begin

    perform auth.has_permission(null, _user_id, 'system.manage_users.register_user');

    perform auth.validate_provider_is_active('email');

    __normalized_email := lower(trim(_email));

    if exists(
            select
            from user_identity ui
            where ui.provider_code = 'email'
              and ui.uid = lower(__normalized_email)
        ) then
        raise exception 'User identity (uid: %) is already in use', __normalized_email
            using errcode = 52102;
    end if;

    insert into user_info (created_by, modified_by, can_login, username, email, display_name)
    values (_created_by, __normalized_email, true, __normalized_email, __normalized_email, _display_name)
    returning * into __new_user;

    insert into user_identity(created_by, modified_by, provider_code, uid, user_id, password_hash)
    values (_created_by, __normalized_email, 'email', __normalized_email, __new_user.user_id, _password_hash);

    perform auth.update_user_data(_created_by, _user_id, __new_user.user_id, 'email', _user_data);

    return query
        select __new_user.user_id
             , __new_user.code
             , __new_user.uuid::text
             , __new_user.username
             , __new_user.email
             , __new_user.display_name;
-- 		from __new_user;
end;
$$;

create function get_user_by_username(_tenant_id int, _username text)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text,
                __roles        text,
                __permissions  text
            )
    language plpgsql
as
$$
begin

    if not exists(select
                  from tenant_user tu
                           inner join user_info ui on ui.user_id = tu.user_id
                  where tenant_id = _tenant_id
                    and ui.username = lower(_username)) then
        perform auth.throw_no_access(_tenant_id, _username);
    end if;

    return query
        select tu.user_id,
               ui.code,
               ui.uuid,
               ui.username,
               ui.email,
               ui.display_name,
               upc.groups,
               upc.permissions
        from tenant_user tu
                 inner join user_info ui on ui.user_id = tu.user_id
                 inner join auth.user_permission_cache upc on ui.user_id = upc.user_id and upc.tenant_id = _tenant_id
        where tu.tenant_id = _tenant_id
          and ui.username = _username;
end;

$$;


-- WARNING: returns password hash, do not use for anything else than authentication, SYSTEM account is the only one with proper permission
create function auth.get_user_by_email_for_authentication(_user_id int, _email text)
    returns table
            (
                __user_id       bigint,
                __code          text,
                __uuid          text,
                __username      text,
                __email         text,
                __display_name  text,
                __provider      text,
                __password_hash text,
                __password_salt text
            )
    language plpgsql
as
$$
declare
    __target_user_id   bigint;
    __target_uid_id    bigint;
    __normalized_email text;
    __is_active        bool;
    __is_locked        bool;
begin

    perform auth.has_permission(null, _user_id, 'system.authentication.get_data');

    perform auth.validate_provider_is_active('email');

    __normalized_email := lower(trim(_email));

    select ui.user_id, uid.user_identity_id, ui.is_active, ui.is_locked
    from user_identity uid
             inner join user_info ui on uid.user_id = ui.user_id
    where uid.provider_code = 'email'
      and uid.uid = __normalized_email
    into __target_user_id, __target_uid_id, __is_active, __is_locked;

    if __is_active is null then
        raise exception 'User identity (uid: %) does not exist', __normalized_email
            using errcode = 52103;
    end if;

    perform update_last_used_provider(__target_user_id, 'email');

    if not __is_active then
        raise exception 'User (email: %) is not in active state', __normalized_email
            using errcode = 52105;
    end if;

    if __is_locked then
        raise exception 'User (email: %) is locked out', __normalized_email
            using errcode = 52106;
    end if;

    return query
        select ui.user_id,
               ui.code,
               ui.uuid::text,
               ui.username,
               ui.email,
               ui.display_name,
               'email',
               uid.password_hash,
               uid.password_salt
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = 'email'
          and uid.uid = __normalized_email;
end;

$$;

-- for external authentication provider flows
create or replace function auth.ensure_user_from_provider(_created_by text, _user_id bigint, _provider_code text,
                                                          _provider_uid text,
                                                          _username text,
                                                          _display_name text, _email text default null,
                                                          _user_data text default null)
    returns table
            (
                __user_id      bigint,
                __code         text,
                __uuid         text,
                __username     text,
                __email        text,
                __display_name text
            )
    language plpgsql
as
$$
declare
    __last_id bigint;
begin

    if lower(_provider_code) = 'email' then
        raise exception 'User (username: %) cannot be ensured for email provider, use registration for that', _username
            using errcode = 52101;
    end if;

    perform auth.validate_provider_is_active(_provider_code);

    select user_id
    from user_identity uid
    where uid.provider_code = _provider_code
      and uid.uid = _provider_uid
    into __last_id;

    if __last_id is null then
        insert into user_info(created_by, modified_by, username, email, display_name, last_used_provider_code)
        values (_created_by, _created_by, lower(_username), lower(_email), _display_name, _provider_code)
        returning user_id into __last_id;

        insert into user_identity(created_by, modified_by, provider_code, uid, user_id)
        values (_created_by, _created_by, _provider_code, _provider_uid, __last_id);

        perform auth.update_user_data(_email, _user_id, __last_id, _provider_code, _user_data);

    end if;

    perform unsecure.update_last_used_provider(__last_id, _provider_code);

    return query
        select ui.user_id,
               ui.code,
               ui.uuid::text,
               ui.username,
               ui.email,
               ui.display_name
        from user_identity uid
                 inner join user_info ui on uid.user_id = ui.user_id
        where uid.provider_code = _provider_code
          and uid.uid = _provider_uid;
end;
$$;

create function auth.update_user_data(_modified_by text, _user_id bigint, _target_user_id bigint, _provider text,
                                      _user_data text)
    returns table
            (
                __user_id      bigint,
                __user_data_id bigint
            )
    language plpgsql
as
$$
begin

    if __user_id <> _target_user_id then
        perform auth.has_permission(null, _user_id, 'system.users.update_user');
    end if;


end;
$$;

--
-- create function auth.get_tenant_permissions(_tenant_id int, _user_id bigint)
--     returns table
--             (
--                 __user_id     bigint,
--                 __groups      text,
--                 __permissions text
--             )
--     language sql
-- as
-- $$
-- select upc.user_id, array_to_string(upc.groups, ';'), array_to_string(upc.permissions, ';')
-- from user_permission_cache upc
--          inner join public.tenant t on upc.tenant_id = t.tenant_id
-- where t.tenant_id = _tenant_id
--   and upc.user_id = _user_id;
-- $$;
--
--
-- create or replace function public.calculate_roles_and_permissions(_user_id bigint, _provider_groups text[], _provider_roles text[])
--     returns table
--             (
--                 __roles       text[],
--                 __permissions text[]
--             )
--     language plpgsql
--     rows 1
-- as
-- $$
-- declare
--     __user_id int;
--     __gs      text[];
--     __ps      text[];
-- begin
--
--     select user_id
--     from user_info ui
--     where ui.oid = _oid
--     into __user_id;
--
--     delete
--     from user_group_member
--     where user_id = __user_id
--       and (
--             (mapping_id is not null
--                 and group_id not in (select distinct ugm.group_id
--                                      from unnest(_provider_groups) g
--                                               inner join public.user_group_mapping ugm on ugm.mapped_object_id = g)
--                 )
--             or manual_assignment
--         );
--
--     insert into user_group_member(user_id, group_id, mapping_id, manual_assignment)
--     select distinct __user_id, ugm.group_id, ugm.ug_mapping_id, false
--     from unnest(_provider_groups) g
--              inner join public.user_group_mapping ugm
--                         on ugm.mapped_object_id = g
--     where ugm.group_id not in (select group_id from user_group_member where user_id = __user_id);
--
--     with users_groups as (select ugm.group_id
--                           from user_group_member ugm
--                           where ugm.user_id = __user_id),
--          groups as (select distinct ps.perm_set_id, ps.code
--                     from users_groups ug
--                              inner join permission_assignment uga on ug.group_id = uga.group_id
--                              inner join auth.perm_set ps on uga.perm_set_id = ps.perm_set_id),
--          user_permissions as (select sp.full_code
--                               from groups r
--                                        inner join auth.perm_set_perm psp on r.perm_set_id = psp.perm_set_id
--                                        join auth.permission p on psp.permission_id = p.permission_id
--                                        inner join auth.permission sp on sp.node_path <@ p.node_path
--                               order by sp.full_code)
--     select array_agg(distinct groups.code)                      gs,
--            array_agg(distinct user_permissions.full_code::text) ps
--     from groups,
--          user_permissions
--     into __gs, __ps;
--
--
--     return query
--         update auth.user_permission_cache
--             set modified = now()
--                 , groups = coalesce(__gs, array []::text[])
--                 , permissions = coalesce(__ps, array []::text[])
--             where user_id = __user_id
--             returning groups, permissions;
-- end;
-- $$;


/***
 *    ██╗███╗---██╗██╗████████╗██╗-█████╗-██╗---------██████╗--█████╗-████████╗-█████╗-
 *    ██║████╗--██║██║╚══██╔══╝██║██╔══██╗██║---------██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗
 *    ██║██╔██╗-██║██║---██║---██║███████║██║---------██║--██║███████║---██║---███████║
 *    ██║██║╚██╗██║██║---██║---██║██╔══██║██║---------██║--██║██╔══██║---██║---██╔══██║
 *    ██║██║-╚████║██║---██║---██║██║--██║███████╗----██████╔╝██║--██║---██║---██║--██║
 *    ╚═╝╚═╝--╚═══╝╚═╝---╚═╝---╚═╝╚═╝--╚═╝╚══════╝----╚═════╝-╚═╝--╚═╝---╚═╝---╚═╝--╚═╝
 *    ---------------------------------------------------------------------------------
 */

create or replace function load_initial_data()
    returns setof int
    language plpgsql
as
$$
declare
begin

    -- COMMMON WITH ALL DATABASES

    insert into const.sys_params(created_by, group_code, code, number_value)
    values ('initial', 'auth', 'perm_cache_timeout_in_s', 15); -- 15seconds intentionally for better debugging

    perform unsecure.create_system_user();
    perform unsecure.create_permission_by_path_as_system('System', _is_assignable := true);

    perform unsecure.create_user_group_as_system(null, 'System', true, true);

    perform unsecure.add_user_to_group_as_system('system', 'System', null);
    perform auth.lock_user_group('system', 1, null, 1);

    perform unsecure.create_perm_set_as_system('System', null, true, _is_assignable := true,
                                               _permissions := array ['system']);
    perform unsecure.assign_permission_as_system(null, 1, null, 'system');
    perform unsecure.set_permission_as_assignable('system', 1, 1, null, false);

    perform unsecure.create_primary_tenant();

    perform unsecure.create_permission_by_path_as_system('Authentication', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Get data', 'system.authentication');

    perform unsecure.create_permission_by_path_as_system('Areas', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Public', 'system.areas');
    perform unsecure.create_permission_by_path_as_system('Admin', 'system.areas');

    perform unsecure.create_permission_by_path_as_system('Manage permissions', 'system', false);
    perform unsecure.create_permission_by_path_as_system('Create permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Update permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Delete permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Create permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Update permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Delete permission set', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Assign permission', 'system.manage_permissions');
    perform unsecure.create_permission_by_path_as_system('Unassign permission', 'system.manage_permissions');

    perform unsecure.create_permission_by_path_as_system('Manage users', 'system');
    perform unsecure.create_permission_by_path_as_system('Register user', 'system.manage_users');

    perform unsecure.create_permission_by_path_as_system('Manage tenants', 'system');
    perform unsecure.create_permission_by_path_as_system('Create tenant', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Update tenant', 'system.manage_tenants');
    perform unsecure.create_permission_by_path_as_system('Assign owner', 'system.manage_tenants');

    perform unsecure.create_permission_by_path_as_system('Manage providers', 'system');
    perform unsecure.create_permission_by_path_as_system('Create provider', 'system.manage_providers');
    perform unsecure.create_permission_by_path_as_system('Update provider', 'system.manage_providers');
    perform unsecure.create_permission_by_path_as_system('Delete provider', 'system.manage_providers');

    perform unsecure.create_permission_by_path_as_system('Manage groups', 'system');
    perform unsecure.create_permission_by_path_as_system('Create group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Update group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Lock group', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Create member', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete member', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Create mapping', 'system.manage_groups');
    perform unsecure.create_permission_by_path_as_system('Delete mapping', 'system.manage_groups');

    perform unsecure.create_perm_set_as_system('System admin', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants', 'system.manage_providers'
                                                   , 'system.manage_users']);


    perform unsecure.create_perm_set_as_system('Tenant creator', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants.create_tenant']);

    perform unsecure.create_perm_set_as_system('Tenant admin', 1, true, _is_assignable := true,
                                               _permissions := array ['system.manage_tenants']);

    perform unsecure.create_perm_set_as_system('Tenant owner', null, true, _is_assignable := true,
                                               _permissions := array ['system.manage_groups'
                                                   , 'system.manage_tenants.update_tenant'
                                                   , 'system.manage_tenants.assign_owner']);

    perform unsecure.create_user_group_as_system(1, 'Tenant admins', true, true);
    perform unsecure.assign_permission_as_system(1, 2, null, 'tenant_admin');

    perform auth.create_provider('initial', 1, 'email', 'Email authentication', false);
    perform auth.create_provider('initial', 1, 'aad', 'Azure authentication', false);

    -- UNIQUE FOR THIS DATABASE

--     insert into tenant (created_by, modified_by, name, code, is_removable, is_assignable)
--     values ('system', 'system', 'App 1', 'app1', true, true)
--          , ('system', 'system', 'App 2', 'app2', true, true);
end
$$;

/***
 *    ██████╗ ██████╗     ██████╗ ███████╗██████╗ ███╗   ███╗██╗███████╗███████╗██╗ ██████╗ ███╗   ██╗███████╗
 *    ██╔══██╗██╔══██╗    ██╔══██╗██╔════╝██╔══██╗████╗ ████║██║██╔════╝██╔════╝██║██╔═══██╗████╗  ██║██╔════╝
 *    ██║  ██║██████╔╝    ██████╔╝█████╗  ██████╔╝██╔████╔██║██║███████╗███████╗██║██║   ██║██╔██╗ ██║███████╗
 *    ██║  ██║██╔══██╗    ██╔═══╝ ██╔══╝  ██╔══██╗██║╚██╔╝██║██║╚════██║╚════██║██║██║   ██║██║╚██╗██║╚════██║
 *    ██████╔╝██████╔╝    ██║     ███████╗██║  ██║██║ ╚═╝ ██║██║███████║███████║██║╚██████╔╝██║ ╚████║███████║
 *    ╚═════╝ ╚═════╝     ╚═╝     ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
 *
 */

grant usage on schema const, unsecure, ext, auth, helpers to keen_auth_sample;

/***
 *    ██████╗--██████╗-███████╗████████╗-----██████╗██████╗-███████╗-█████╗-████████╗███████╗
 *    ██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝----██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝
 *    ██████╔╝██║---██║███████╗---██║-------██║-----██████╔╝█████╗--███████║---██║---█████╗--
 *    ██╔═══╝-██║---██║╚════██║---██║-------██║-----██╔══██╗██╔══╝--██╔══██║---██║---██╔══╝--
 *    ██║-----╚██████╔╝███████║---██║-------╚██████╗██║--██║███████╗██║--██║---██║---███████╗
 *    ╚═╝------╚═════╝-╚══════╝---╚═╝--------╚═════╝╚═╝--╚═╝╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝
 *    ---------------------------------------------------------------------------------------
 */

select *
from load_initial_data();

select now(), version();

